<!DOCTYPE html>

<html>
  <head>
    <title>Amoebot Project</title>
  </head>
  <body>
    <button id='request' onclick='manager.stepFunction();' type='button'>next</button>
    </br>
    <svg id='camera'>
      <rect fill="None" height=100% stroke='black' stroke-width=0.5% width=100%></rect>
      <g id='grid'></g>
      <g id='amoebots'></g>
      <circle cx=0 cy=0 fill='red' id='origin' r=.75%></circle>
    </svg>

    <script type='text/javascript'>
      var nameSpaceURI = 'http://www.w3.org/2000/svg';
      var algName = 'random';
      var cameraDim = {w: 500, h: 300};
      var unit = 10;

      var originPos = {x: 0, y: 0};
      var amoebotsPos = [];
      var leader = -1;

      var bot_history = {};
      var current_step = 0;
      const phase_colors = {
        '-1': 'white',
        0 : 'orange',
        1 : 'red',
        2 : 'blue',
        3 : 'green',
        4 : 'purple'
      };
      var manager = null;


      (function prepareVisuals() {
        var camera = document.getElementById('camera');
        camera.setAttribute('width', cameraDim.w);
        camera.setAttribute('height', cameraDim.h);

        var gridLines = [];
        var zontGridDisp = unit * Math.sqrt(3);
        for(var i = -zontGridDisp; i <= cameraDim.h + zontGridDisp; i += zontGridDisp / 2) {
          gridLines.push({p1: {x: -2 * unit, y: i}, p2: {x: cameraDim.w + 2 * unit, y: i}});
        }

        var vertGridDisp = (Math.floor(cameraDim.w / (2 * unit)) + 1) * unit;
        for(var i = -vertGridDisp; i <= cameraDim.w + vertGridDisp; i += unit) {
          gridLines.push({p1: {x: i, y: -2 * zontGridDisp}, 
            p2: {x: i - (cameraDim.h + 4 * zontGridDisp) / Math.sqrt(3),
              y: cameraDim.h + 2 * zontGridDisp
            }
          });
          gridLines.push({p1: {x: i, y: -2 * unit * Math.sqrt(3)},
            p2: {x: i + (cameraDim.h + 4 * zontGridDisp) / Math.sqrt(3),
              y: cameraDim.h + 2 * zontGridDisp
            }
          });
        }

        for(gridLine of gridLines) {
          var newLine = document.createElementNS(nameSpaceURI, 'line');
          newLine.setAttribute('stroke', 'black');
          newLine.setAttribute('stroke-width', '0.1%');
          newLine.setAttribute('x1', gridLine.p1.x);
          newLine.setAttribute('x2', gridLine.p2.x);
          newLine.setAttribute('y1', gridLine.p1.y);
          newLine.setAttribute('y2', gridLine.p2.y);
          camera.getElementById('grid').appendChild(newLine);
        }
      })();


      (function setDrag() {
        var camera = document.getElementById('camera');
        var dragLoc = {x: 0, y: 0};

        camera.onmousedown = function(event) {
          camera.onmousemove = gridDrag;
          camera.onmouseup = endDrag;
          camera.onmouseleave = endDrag;
          dragLoc.x = event.clientX;
          dragLoc.y = event.clientY;
        }

        function gridDrag(event) {
          originPos.x += event.clientX - dragLoc.x;
          originPos.y += event.clientY - dragLoc.y;
          updateVisuals();
          dragLoc.x = event.clientX;
          dragLoc.y = event.clientY;
        }

        function endDrag() {
          camera.onmousemove = null;
          camera.onmouseup = null;
          camera.onmouseleave = null;
        }
      })();


      function updateVisuals() {
        (function updateOrigin() {
          var origin = document.getElementById('origin');
          origin.setAttribute('cx', originPos.x);
          origin.setAttribute('cy', originPos.y);
        })();

        

        (function updateAmoebots() {
          var amoebotVis = manager.bot_dict;
          for(var i = 0; i < amoebotVis.length; i++) {
            var amoebotParts = amoebotVis[i].visualRep;
            var tailLocation = squareToTriangle(amoebotVis[i].tail);
            var headLocation = squareToTriangle(amoebotVis[i].head);

            amoebotParts.botTail.setAttribute('cx', originPos.x + tailLocation.x);
            amoebotParts.botTail.setAttribute('cy', originPos.y + tailLocation.y);

            amoebotParts.botHead.setAttribute('cx', originPos.x + headLocation.x);
            amoebotParts.botHead.setAttribute('cy', originPos.y + headLocation.y);

            for (let agent in amoebotParts.agentSlices) {
              amoebotParts.agentSlices[agent].setAttribute('cx', originPos.x + headLocation.x);
              amoebotParts.agentSlices[agent].setAttribute('cy', originPos.y + headLocation.y);
              if (amoebotParts.agentRotations[agent]) {
                amoebotParts.agentSlices[agent].setAttribute('transform', `rotate(${amoebotParts.agentRotations[agent]}, ${originPos.x + headLocation.x}, ${originPos.y + headLocation.y})`)
              }
            }
            /* TODO: Add agent updates as well
            amoebotParts[2].setAttribute('x1', originPos.x + headLocation.x);
            amoebotParts[2].setAttribute('x2', originPos.x + tailLocation.x);
            amoebotParts[2].setAttribute('y1', originPos.y + headLocation.y);
            amoebotParts[2].setAttribute('y2', originPos.y + tailLocation.y);
            */
          }
        })();

        (function updateGrid() {
          var gridVisual = document.getElementById('grid');
          var moduloX = originPos.x % unit;
          var moduloY = originPos.y % (unit * Math.sqrt(3));
          gridVisual.setAttribute('transform',
            'translate(' + moduloX + ', ' + moduloY + ')'
          );
        })();
      }


      function sendRequest(route) {
        fetch(route, {
          body: JSON.stringify({
            algName: algName,
            amoebotsPos: amoebotsPos,
            leader: leader
          }),
          headers: {'Content-Type': 'application/json'},
          method: 'POST'
        } ).then(function(response) {
          console.log('%cServer says: ' + response.statusText, 'color:lime');
          return response.json();
        }).then(function(text) {
          console.log('%cServer responded:', 'color:lime');
          for(let val in text) {
            console.log('%c' + val + ':', 'color:blue', text[val]);
          }
          amoebotsPos = text['amoebotsPos'];
          leader = text['leader'];
          updateVisuals();
        }).catch(function(err) {
          console.log("%cfetch error: " + err.message, 'color:red');
        });
      }


      function addAmoebot(x, y) {

        // Handled by Manager
        amoebotsPos.push({head: {x: x, y: y}, tail: {x: x, y: y}});

        // Handled by Visual
        var newAmoebot = document.createElementNS(nameSpaceURI, 'g');
        newAmoebot.setAttribute('class', 'amoebot');

        var amoebotTail = document.createElementNS(nameSpaceURI, 'circle');
        amoebotTail.setAttribute('id', 'tail');
        amoebotTail.setAttribute('fill', 'black');
        amoebotTail.setAttribute('r', '1%');

        var amoebotHead = amoebotTail.cloneNode(true);
        amoebotHead.setAttribute('id', 'head');

        var amoebotBody = document.createElementNS(nameSpaceURI, 'line');
        amoebotBody.setAttribute('id', 'body');
        amoebotBody.setAttribute('stroke', 'black');
        amoebotBody.setAttribute('stroke-width', '1%');

        newAmoebot.appendChild(amoebotTail);
        newAmoebot.appendChild(amoebotHead);
        newAmoebot.appendChild(amoebotBody);
        camera.getElementById('amoebots').appendChild(newAmoebot);

        // Called by visual
        updateVisuals();
        // return newAmoebot
        return('Amoebot added to: ' + x + ', ' + y );
      }

      function getHistory() {
        /*
        Get history JSON from external source.
        Requires the file to be served over http/https.
        */
        fetch('history')
        .then(response => response.json())
        .then(data => bot_history = data);
      }

      function addBotsFromHistory(){
        /*
        Adds bots from bot_history to the grid. 
        Modified x and y position reflect the difference
        in grid systems between the python sim and this,
        for the moment.
        */

        if (bot_history == {}) return;
        for (var i in bot_history['0']){
          const bot = bot_history['0'][i];
          if (bot.x % 2 == 0) {
            addAmoebot(bot.x/2, bot.y);
          } 
          else {
            addAmoebot((bot.x - 1) / 2, (bot.y));
          }
        }
      }


      function squareToTriangle(point) {
        /*
        Shearing function to turn points from the 
        square plane into triangular points.
        */
        newPoint = {x: 0, y: 0};
        newPoint.x += point.x * unit;
        if (point.y % 2 == 1){
          newPoint.x += (1 / 2) * unit;
        }
        newPoint.y -= (point.y * Math.sqrt(3) / 2) * unit;
        return(newPoint);
      }

      class AmoebotManager {
        /*
        Manages the list of bot visuals and their current positions.
        */
        constructor(bot_history) {
          this.bot_history = bot_history;
          this.bot_dict = [];
          this.step = 0;
          for (let i in this.bot_history['0']) {
            this.bot_dict.push(new AmoebotData(
              this.bot_history['0'][i].x,
              this.bot_history['0'][i].y,
              i, 
              this.bot_history['0'][i].agents_on
            ));
          }
        }

        stepFunction () {
          /*
          Updates the bots' positions and states from previous step.
          One step is one full pass through all the bots.
          */
          this.step ++;
          for (let i in this.bot_history[this.step]) {
            let historical_bot = this.bot_history[this.step][i];
            let curr_bot = this.bot_dict[i];

            // This is arbitrary for now, as they don't move yet
            curr_bot.head.x = (historical_bot.x % 2 == 0) ? historical_bot.x / 2 : (historical_bot.x - 1) / 2;
            curr_bot.head.y = historical_bot.y;

            curr_bot.tail.x = (historical_bot.x % 2 == 0) ? historical_bot.x / 2 : (historical_bot.x - 1) / 2;
            curr_bot.tail.y = historical_bot.y;

            curr_bot.agent_stage = historical_bot.agents_on;
            curr_bot.agent_statuses_stage = {
              'agent0': historical_bot.agent0, 
              'agent1': historical_bot.agent1, 
              'agent2': historical_bot.agent2
            };
            curr_bot.update();
          }
          updateVisuals();
        }
      }

      class AmoebotData {
        /*
        Data representation of each bot for the manager.
        Contains a reference to the visual SVG elements.
        */
        constructor(x, y, id, agents) {
          // X coord
          // Account for X skew in old graph layout
          this.head = {
            x : (x % 2 == 0) ? x / 2 : (x - 1) / 2,
            y
          }
          this.tail = {
            x : (x % 2 == 0) ? x / 2 : (x - 1) / 2,
            y
          }
          // ID
          this.id = id;
          // List of P-S pairs
          this.agents = agents;
          // Staging area for adding new agents
          this.agent_stage = [
            ["",""],
            ["",""],
            ["",""]
          ];

          this.agent_statuses = {
            'agent0': -1,
            'agent1': -1,
            'agent2': -1
          };

          this.agent_statuses_stage = {};
          // Reference to visual representation
          this.visualRep = new AmoebotVisual(this);
        }

        update () {
          /*
          Update bot positions and statuses. If there are any differences,
          modify the data representation and visuals.
          */
          if (JSON.stringify(this.agent_stage) != JSON.stringify(this.agents)) {
            for (let i = 0; i < this.agent_stage.length; i ++) {
              if (JSON.stringify(this.agent_stage[i]) != JSON.stringify(this.agents[i])) {
                this.visualRep.createAgent(this.agent_stage[i][0], this.agent_stage[i][1]);
                this.agents[i] = this.agent_stage[i];
              }
            }
          }
          for (let i = 0; i < this.agent_stage.length; i++) {
            if (this.agent_statuses_stage[`agent${i}`] != this.agent_statuses[`agent${i}`]) {
              this.visualRep.updateAgentSlices(i, this.agent_statuses_stage[`agent${i}`]);
              this.agent_statuses[`agent${i}`] = this.agent_statuses_stage[`agent${i}`];
            }
          }
        }
      }

      class AmoebotVisual {
        /*
        SVG group (g element) representing the bot on the grid.
        */
        constructor(abotData){
          // AmoebotData instance
          this.abot = abotData;
          // ID
          this.id = abotData.id;
          // Var for G element - contains bot and all agent layers
          this.visualRep = document.createElementNS(nameSpaceURI, 'g');
          this.visualRep.setAttribute('class', 'amoebot');
          this.visualRep.setAttribute('id', `abot-${this.id}`);

          // Create parts in reverse order because of SVG layering
          this.botTail = this.createBotPart('tail', this.id);
          this.botHead = this.createBotPart('head', this.id);
          this.agentSlices = [];
          this.agentRotations = [];

          camera.getElementById('amoebots').appendChild(this.visualRep);
          //updateVisuals();
        }

        createBotPart(partType, id) {
          /*
          Creates a head or tail, or any other bot part that may be needed
          to stand on a point. Add this element to the group.
          NOTE: bot parts must be created in reverse order of visualization.
          I.E., create the tail first and head last so head is on top.
          */
          let newAmoebotPart = document.createElementNS(nameSpaceURI, 'circle');
          newAmoebotPart.setAttribute('id', `${partType}-${id}`);
          const pos = squareToTriangle({x:this.abot.head.x, y:this.abot.head.y});
          newAmoebotPart.setAttribute('cx', pos.x);
          newAmoebotPart.setAttribute('cy', pos.y);
          newAmoebotPart.setAttribute('fill', 'black');
          newAmoebotPart.setAttribute('r', '1%');
          // Add to group visually
          this.visualRep.appendChild(newAmoebotPart);
          // Return a reference
          return newAmoebotPart;
        }

        createAgent(incoming, outgoing) {
          /*
          Creates an agent based on the data's incoming and outgoing ports 
          and rotate as such. NOTE: ports are still completely anonymized and randomized to the bots. 
          These arguments are just keywords that can help us create visuals.
          */

          let spaceBetween = ['right', 'bottom right', 'bottom left', 'left', 'top left', 'top right'];

          let incIndex = spaceBetween.indexOf(incoming);
          let outIndex = spaceBetween.indexOf(outgoing);
          let rightIndex = spaceBetween.indexOf('right');

          let portsBetween = (outIndex - incIndex < 0) ? outIndex - incIndex + 6 : outIndex - incIndex;
          let fromRight = incIndex - rightIndex;
          let angleBetween = (100/6) * portsBetween;
          let angleToRotate = (60 * fromRight);

          this.agentRotations.push(angleToRotate);



          let newAgent = document.createElementNS(nameSpaceURI, 'circle');
          const pos = squareToTriangle({x:this.abot.head.x, y:this.abot.head.y});
          newAgent.setAttribute('fill', 'transparent');//phase_colors['-1']);
          newAgent.setAttribute('stroke', phase_colors['0']);
          newAgent.setAttribute('r', '0.5%');
          newAgent.setAttribute('cx', pos.x);
          newAgent.setAttribute('cy', pos.y);
          newAgent.setAttribute('stroke-width', '1%');
          newAgent.setAttribute('stroke-dasharray', `calc(${(angleBetween== 0) ? 98 : angleBetween - 2} * 3.142% / 100)  3%`);
          newAgent.setAttribute('transform', `rotate(${angleToRotate}, ${pos.x}, ${pos.y})`)
          this.agentSlices.push(newAgent);
          
          this.visualRep.appendChild(newAgent);
        }

        updateAgentSlices(index, newState) {
          /*
          Change colors of agents etc. when a new state is detected.
          */
          this.agentSlices[index].setAttribute('stroke', phase_colors[newState]);
          updateVisuals();
        }
      }

      function initManager() {
        /*
        initialize window.manager.
        Adds bots to the grid.
        */
        if (bot_history == {}) return;
        manager = new AmoebotManager(bot_history);
        updateVisuals();
      }

      function timedSteps() {
        // Auto step simulation.
        let motor = setInterval(() => {manager.stepFunction();}, 5000);
      }

      getHistory();
      initManager();


    </script>
  </body>
</html>
















